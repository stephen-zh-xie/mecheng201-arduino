#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    _lightLeft,      sensorReflection)
#pragma config(Sensor, in2,    _lightMid,       sensorReflection)
#pragma config(Sensor, in3,    _lightRight,     sensorReflection)
#pragma config(Sensor, dgtl1,  _btnStop,        sensorTouch)
#pragma config(Sensor, dgtl2,  _btnStart,       sensorTouch)
#pragma config(Sensor, dgtl3,  _sonar,          sensorSONAR_mm)
#pragma config(Sensor, dgtl5,  _encRight,       sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  _encLeft,        sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  _LED_Right,      sensorDigitalOut)
#pragma config(Sensor, dgtl10, _LED_Left,       sensorDigitalOut)
#pragma config(Sensor, dgtl11, _armLimit_low,   sensorTouch)
#pragma config(Sensor, dgtl12, _armLimit_high,  sensorTouch)
#pragma config(Sensor, I2C_1,  _armEncoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           _motorArm,      tmotorVex269_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           _motorRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           _motorLeft,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// -----------  DO NOT MODIFY anything ABOVE this line! ----------- //

#include "backgroundProcesses2021.c"

/* Timers:
T_1	Free
T_2	Free
T_3	Free
T_4	Used by checkButtons() -- DO NOT USE
*/

// ---------------------- Defining physical robot parameters --------------------------
// Update these numbers to match the physical robot (information found in the lab manual)
int drivingWheelDiameter = 103;		// diameter of the driving wheels [mm]
int robotWidth = 250;							// width of the robot including the wheel thickness [mm]
int wheelWidth = 22;							// width of the driving wheel [mm]
float drivingWheelRatio = 0.0;	// ratio of wheel shaft rotations to wheel encoder shaft rotations
float armRatio = 0.0;						// ratio of arm shaft rotations to arm encoder shaft rotations
float wheelEncoderCounts = 0.0;	// number of encoder ticks per 1 revolution of wheel encoder
float armEncoderCounts = 0.0;		// number of encoder ticks per 1 revolution of arm encoder
// ------------------------------------------------------------------------------------



#define BLACKMIN 2100 //CHANGE WITH checkColour()
#define BLACKMAX 3000 //CHANGE WITH checkColour()
//Diameter = 22.5cm

#include "C12_Functions.c"
// #include "C12_Tasks.c"


//ACTIONS
void checkColour(); //Function to check colour values
void driveToSonar(int distance);
void turnFindCan();
void checkSonarArm();

task main()
{
	//Background Tasks
	startTask(checkArm);     // DO NOT DELETE THIS LINE
	startTask(checkButtons); // DO NOT DELETE THIS LINE
	//------------------------ Insert main code below this line ---------------------------------
	//-------------------------------------------------------------------------------------------

	clearDebugStream();

	waitForStart();//NEVER REMOVE

	armUp(50);

	//checkSonarArm();

	//turnFindCan();
	//doAllTasks();

	//driveStraight(1000,25);

	//task5();

	//setSensor(LeftEnc, 0);
	//setSensor(RightEnc, 0);

	//checkColour();

	//task2();
	//task3();

	//task4();

	//driveToSonar(0);

	//-------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------
	stopAllTasks();	// DO NOT DELETE THIS LINE - end of program - stop everything
}


//-----------------------------------------------------------------------------
void checkColour(){
	//waitForStart();

	int sensorL;
	int sensorM;
	int sensorR;

	while(1){ //Infinite loop
		sensorL = readSensor(LeftLight);
		sensorM = readSensor(MidLight);
		sensorR = readSensor(RightLight);


		printf("Left sensor value: %d",sensorL);
		printf("Mid sensor value: %d",sensorM);
		printf("Right sensor value: %d",sensorR);


		/*
		if((sensorL>=BLACKMIN) && (sensorL<=BLACKMAX)){
			printf("BLACK");
		}else if((sensorM>=BLACKMIN) && (sensorM<=BLACKMAX)){
			printf("BLACK");
		}else if((sensorR>=BLACKMIN) && (sensorR<=BLACKMAX)){
			printf("BLACK");
		}else{
			printf("Waiting");
		}
		*/


		delay(1000);

	}
}

void driveToSonar(int distance){
	//waitForStart(); // Waits for start - important
	// Set variables - sensor value
	int sonar = -1;
	// Set up while loop - change exit condition later
	while (1) {
		delay(50);
		sonar = readSensor(sonarSensor);
		printf("Sonar: %d", sonar);
	}
}

void turnFindCan(){
		int canFound = 0;
		int sonar = -1;

		//TURNS RIGHT
		motorPower(LeftMotor,22);
		motorPower(RightMotor,-22);

		//GET REFERENCE VALUE - MUST BE NOT FACING CAN

		while(!canFound){
				delay(50);
				sonar = readSensor(sonarSensor);

				if((sonar) > 100){
					canFound = 1;
				}
		}

		motorPower(LeftMotor,0);
		motorPower(RightMotor,0);
}
void checkSonarArm(){
	armUp(50);

	int sonar = -1;
	// Set up while loop - change exit condition later
	while (1) {
		armTime(-20,400);

		sonar = readSensor(sonarSensor);
		printf("Sonar1: %d", sonar);
		delay(250);

		sonar = readSensor(sonarSensor);
		printf("Sonar2: %d", sonar);
		delay(250);

		sonar = readSensor(sonarSensor);
		printf("Sonar3: %d", sonar);
		delay(250);

		printf("");
	}
}
