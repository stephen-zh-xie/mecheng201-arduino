#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    _lightLeft,     sensorNone)
#pragma config(Sensor, in2,    _lightMid,      sensorLineFollower)
#pragma config(Sensor, in3,    _lightRight,    sensorLineFollower)
#pragma config(Sensor, dgtl1,  _encRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  _encLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  _armLimit_low,  sensorTouch)
#pragma config(Sensor, dgtl8,  _sonar,         sensorSONAR_cm)
#pragma config(Sensor, I2C_3,  _armEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           _motorRight,   tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, None)
#pragma config(Motor,  port3,           _motorLeft,    tmotorVex393_MC29, openLoop, driveLeft, encoderPort, None)
#pragma config(Motor,  port6,           _motorArm,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "backgroundProcesses2021RVW.c"

// ---------------------- Defining physical robot parameters --------------------------
int isIdeal = 0;									// decide whether to use ideal robot (value = 1) or with simulated imperfections (value = 0)
int robotNumber = 1;							// Give robot number
// The numbers below are setup for the Squarebot on RVW. DO NOT CHANGE
int drivingWheelDiameter = 53;		// diameter of the driving wheels [mm]
int robotWidth = 230;							// width of the robot including the wheel thickness [mm]
int wheelWidth = 14;							// width of the driving wheel [mm]
float drivingWheelRatio = 1.0;		// ratio of wheel shaft rotations to wheel encoder shaft rotations
float armRatio = 0.2;							// ratio of arm shaft rotations to arm encoder shaft rotations
float wheelEncoderCounts = 360.0;	// number of encoder ticks per 1 revolution of wheel encoder
float armEncoderCounts = 360.0;		// number of encoder ticks per 1 revolution of arm encoder
// ------------------------------------------------------------------------------------

#define BLACKMIN 1100
#define BLACKMAX 1450
#define BROWNMIN 800
#define BROWNMAX 1200
//Diameter = 22.5cm

void waitForStart()
{
	int result = 0;
	while (result == 0) {
		delay(50);
		//result = readSensor(StartButton);
	}
	delay(800);
}

void armTime(float armPower, int time)
{
	armPower = saturate(armPower, -100, 100);
	motorPower(ArmMotor, armPower);
	delay(time);
	motorPower(ArmMotor, 0);
}

int count_to_mm(int encoderCount){
	int distanceTravelled = 0;

	//distanceTravelled = (encoderCount/360.0) * 3.0 / 5.0 * drivingWheelDiameter*PI;
	distanceTravelled = (encoderCount/360.0) * drivingWheelDiameter*PI;

	return distanceTravelled;
}


int findArmAngle(float encoder){
	// Takes an encoder count and returns the angle of the arm, with zero being horizontal
	// 5050 encoder counts for a single arm revolution
	// Assume the arm encoder's already been reset, and zero is at the bottom
	float bottomAngle = -29; // In millimetres
	float armAngle;

	// To find angle above bottom, just divide by 5050 and multiply by 360
	// So I'll just add the (negative) bottom angle to get the horizontal at zero
	armAngle = ( encoder * 360 / 5050 ) + bottomAngle;
	return armAngle*-1;
}

void resetArmAngle() {
	armDown(50);
	setSensor(EncoderArm, 0);
}

void getLineColour(int direction, float power){
	int forward;
	int leftEncoder;
	int rightEncoder;
	int leftPower;
	int rightPower;
	int Kp = 1.5;
	int onLine = 0;
	int sensorL;
	int sensorM;
	int sensorR;

	setSensor(LeftEnc, 0);
	setSensor(RightEnc, 0);

	forward = sgn(direction);

	if (power < 0) {
		power = power * -1;
	}
	power = saturate(power, 0, 100);
	power = power / 100 * 127;

	leftPower = power;
	rightPower = power;

	motorPower(LeftMotor, power * forward);
	motorPower(RightMotor, power * forward);

	//INFINITE LOOP
	while (1) {
		delay(50);

		sensorL = readSensor(LeftLight);
		sensorM = readSensor(MidLight);
		sensorR = readSensor(RightLight);

		leftEncoder = readSensor(LeftEnc);
		rightEncoder = readSensor(RightEnc);

		leftPower = power - Kp * forward * (leftEncoder - rightEncoder);
		rightPower = power - Kp * forward * (rightEncoder - leftEncoder);

		// Adjust actual motor speed
		motorPower(LeftMotor, leftPower * forward);
		motorPower(RightMotor, rightPower * forward);

		//datalogDataGroupStart();
		//datalogAddValue(0,sensorL);
		//datalogAddValue(1,sensorM);
		//datalogAddValue(2,sensorR);
		//datalogDataGroupEnd();
	}

	motorPower(LeftMotor, 0);
	motorPower(RightMotor, 0);
}

void checkSonar(){
	motorPower(LeftMotor, 25);
	motorPower(RightMotor, -25);

	int sensor;

	while(1){
		sensor = readSensor(sonarSensor);

		datalogDataGroupStart();
		datalogAddValue(0,sensor);
		datalogDataGroupEnd();

	}


}

void rotateArm(int angle, int tolerance) {
	// Rotates the arm to a specific angle
	// Zero is at the horizontal, so I'll use the findArmAngle function to control position
	// Assume it's already been calibrated
	// Uses a PI controller
	// Everything in degrees (time is in milliseconds)

	// Initialise variables
	int angleError = 0;
	int angleTotal = 0;
	int anglePower = 0;
	int timeInArea = 0;
	int timeRequiredArea = 40;
	int currentEncoder;
	int saturateLower = 1;
	int saturateUpper = 125;

	// Initialise kp and ki values - untested
	float KP = 1;
	float KI = 0.3;

	// Initialise the error
	currentEncoder = readSensor(EncoderArm);
	currentEncoder = findArmAngle(currentEncoder);
	angleError = angle - currentEncoder;

	// Begin loop: Have you been within tolerance of target for some time?
	while ( (angleError > tolerance) || (angleError < -tolerance) || (timeInArea < timeRequiredArea) ) {
		// Loop begins: read angle and set error
		currentEncoder = readSensor(EncoderArm);
		currentEncoder = findArmAngle(currentEncoder);
		angleError = angle - currentEncoder;
		// If angleError isn't so large that it's over the saturation limit, add error to angle total for I part of PI
		if (angleError > (-saturateUpper / KP) && angleError < (saturateUpper / KP)) {
			angleTotal = angleTotal + angleError;
		}
		// Calculate total power
		anglePower = KP * angleError + KI * angleTotal;

		// Saturate power based on error (either forward or backward)
		if (angleError > 0) {
			anglePower = saturate(anglePower, saturateLower, saturateUpper);
		} else if (angleError < 0) {
			anglePower = saturate(anglePower, -saturateUpper, -saturateLower);
		}

		// Send power to arm motor
		motorPower(ArmMotor, anglePower);

		// If the arm is within the tolerance, we increment time
		// This is to prevent it from stopping suddenly and retaining momentum.
		if ( (angleError < tolerance) && (angleError > -tolerance) ) {
			timeInArea = timeInArea + 1;
		}

		// The loop must keep running - we add a 50ms delay before the next iteration
		delay(50);

		datalogDataGroupStart();
		datalogAddValue(0,angleError);
		datalogAddValue(1,anglePower);
		datalogDataGroupEnd();
	}

	// Reset motors
	motorPower(ArmMotor, 0);
}

void turnPI(float degrees){
	float PwrLeft; //FOR NOW
	float PwrRight; // FOR NOW

	int rotation;
	//+ve = CLOCKWISE

	int lowerSaturate = 5;
	int upperSaturate = 30;

	int encoderLeftV;
	int encoderRightV;
	int average;

	int circumfrence = (robotWidth-wheelWidth)*PI;
	float arc;
	float arcDegrees;
	float turnError;

	float Kp = 1.6;
	float Ki = 0.5;
	int turnIntegral = 0;
	float KpPower;
	float KiPower;

	float straightKp = 1;
	float straightPower;
	float straightError;

	float time = 0;
	//float backLashError = -1;
	float backLashError = 0;
	float slowStart = -17;
	float speedUp = 0.1;

	degrees += backLashError;

	//roation variable is used to make all values positive to compare more easily
	rotation = sgn(degrees);

	setSensor(LeftEnc,0);
	setSensor(RightEnc,0);

	do{
		//Both encoder values will return postive values
		encoderLeftV = readSensor(LeftEnc) * rotation;
		encoderRightV = readSensor(RightEnc) * -1 * rotation;

		average = (encoderLeftV + encoderRightV)/2;

		//Take off left, Add to right
		straightError = encoderLeftV - encoderRightV;
		straightPower = straightKp*straightError;

		arc = count_to_mm(average);
		arcDegrees = (arc/circumfrence) * 360;
		turnError = degrees*rotation-arcDegrees;

		KpPower = turnError*Kp;
		KiPower = turnIntegral*Ki;

		PwrLeft  = KpPower + KiPower - straightPower;
		PwrRight = KpPower + KiPower + straightPower;

		if((PwrLeft <=  upperSaturate) && (PwrRight <= upperSaturate)){
			turnIntegral = turnIntegral + turnError;
	  }

	  if(slowStart < -5){
	  	slowStart = slowStart += speedUp;
	  	speedUp = speedUp * 1.1;
		}else{
			slowStart = 0;
		}

		PwrLeft = saturate(PwrLeft,-upperSaturate,upperSaturate);
		PwrRight = saturate(PwrRight,-upperSaturate,upperSaturate);

		PwrLeft = PwrLeft + slowStart;
	  PwrRight = PwrRight + slowStart;

		motorPower(LeftMotor, (PwrLeft * rotation));
		motorPower(RightMotor, (PwrRight * -1 * rotation));

		if(abs(turnError) > 2){ //Was 3 on real robot
			time = 0;
		}else{
			time += 1;
		}

		delay(100);


		//datalogDataGroupStart();
		//datalogAddValue(0,arcDegrees);
		//datalogAddValue(1,PwrLeft);
		//datalogAddValue(2,PwrRight);
		//datalogAddValue(3,slowStart);
		//datalogAddValue(4,straightPower);
		//datalogAddValue(5,straightError);
		//datalogAddValue(6,KpPower);
		//datalogAddValue(7,KiPower);

		//datalogDataGroupEnd();



	}while(time < 20);

	//arcDegrees < degrees*rotation

	motorPower(LeftMotor, 0);
	motorPower(RightMotor, 0);
}

//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------

void driveStraightToLine(int distance, float power) {
	int forward;
	int leftEncoder;
	int rightEncoder;
	int leftPower;
	int rightPower;
	int Kp = 0.05;
	int onLine = 0;
	int sensorL;
	int sensorM;
	int sensorR;

	setSensor(LeftEnc, 0);
	setSensor(RightEnc, 0);

	if (distance == 1) {
		forward = 1;
	}
	else {
		forward = -1;
	}

	if (power < 0) {
		power = power * -1;
	}
	power = saturate(power, 0, 100);
	power = power / 100 * 127;

	leftPower = power;
	rightPower = power;

	motorPower(LeftMotor, power * forward);
	motorPower(RightMotor, power * forward);

	while (!onLine) {
		delay(50);

		sensorL = readSensor(LeftLight);
		sensorM = readSensor(MidLight);
		sensorR = readSensor(RightLight);

		if((sensorL>=BLACKMIN) && (sensorL<=BLACKMAX)){
			onLine = 1;
		}else if((sensorM>=BLACKMIN) && (sensorM<=BLACKMAX)){
			onLine = 1;
		}else if((sensorR>=BLACKMIN) && (sensorR<=BLACKMAX)){
			onLine = 1;
		}

		leftEncoder = readSensor(LeftEnc);
		rightEncoder = readSensor(RightEnc);

		leftPower = power - Kp * forward * (leftEncoder - rightEncoder);
		rightPower = power - Kp * forward * (rightEncoder - leftEncoder);

		// Adjust actual motor speed
		motorPower(LeftMotor, leftPower * forward);
		motorPower(RightMotor, rightPower * forward);
	}

	motorPower(LeftMotor, 0);
	motorPower(RightMotor, 0);
}

//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------

void driveToObjectPI(int distance, int tolerance) {
	// Uses two PI controllers
	// one to control the distance to the object, one to control the turning
	// distance and tolerance in millimetres

	// Initialise variables first
	int distanceError = 0;
	int distanceTotal = 0;
	int distancePower = 0;
	int sonarValue;
	int turnError = 0;
	int turnTotal = 0;
	int turnPower = 0;
	int encoderLeft = 0;
	int encoderRight = 0;
	int encoderAverage = 0;
	int encoderDifference = 0;
	int timeInArea = 0;
	int timeRequiredArea = 20;
	int sonar = -1;
	int saturateLower = 20;
	int saturateUpper = 40;

	// Initialise kp and ki values - experimental
	float distanceKP = 0.5;
	float distanceKI = 0.005;
	float turnKP = 0.8;
	float turnKI = 0.02;

	// Reset sensors, set distanceError to initial value
	setSensor(LeftEnc, 0);
	setSensor(RightEnc, 0);
	distancePower = 25; // keep constant for first sonar loop

	// Begin first loop: Can you spot the object? Note that it is assumed to be straight ahead
	while (sonar == -1) {
		// Loop begins: get encoder count
		encoderLeft = readSensor(LeftEnc);
		encoderRight = readSensor(RightEnc);
		encoderAverage = (encoderLeft + encoderRight) / 2;
		encoderDifference = (encoderLeft - encoderRight);

		// Calculate turnError in millimetres, add to turnTotal
		turnError = encoderDifference;
		turnTotal = turnTotal + turnError;

		// Calculate turn power - doesn't need saturation due to (hopefully) low values
		turnPower = turnKP * turnError + turnKI * turnTotal;

		// Set motor power to constant + turn effect
		motorPower(LeftMotor, (distancePower - turnPower));
		motorPower(RightMotor, (distancePower + turnPower));

		// Check the sonar again
		sonar = readSensor(sonarSensor);

		// Wait 50 milliseconds
		delay(50);
	}

	// Begin second loop: Have you been within tolerance of distance from object for some time?
	while (distanceError > tolerance || distanceError < -tolerance || timeInArea < timeRequiredArea) {
		// Loop begins: get encoder count
		encoderLeft = readSensor(LeftEnc);
		encoderRight = readSensor(RightEnc);
		encoderAverage = (encoderLeft + encoderRight) / 2;
		encoderDifference = (encoderLeft - encoderRight);

		// Calculate distanceError in millimetres
		sonarValue = readSensor(sonarSensor);
		if(sonarValue != -1){
			distanceError = sonarValue - distance;
		}
		// If distanceError is between -125 and 125 (the saturation limits) then add to distanceTotal
		// So that it doesn't add up massive numbers and cause major integrator windup
		if (distanceError > (-saturateUpper / distanceKP) && distanceError < (saturateUpper / distanceKP)) {
			distanceTotal = distanceTotal + distanceError;
		}
		// Calculate turnError in millimetres, add to turnTotal
		// Doesn't need the integrator windup preventor, since error should stay almost at zero
		turnError = encoderDifference;
		turnTotal = turnTotal + turnError;
		// Calculate resulting distance power
		distancePower = distanceKP * distanceError + distanceKI * distanceTotal;

		// Saturate distancePower based on distanceError (either forward or backward)
		if (distanceError > 0) {
			distancePower = saturate(distancePower, saturateLower, saturateUpper);
		} else if (distanceError < 0) {
			distancePower = saturate(distancePower, -saturateUpper, -saturateLower);
		}

		// Calculate turn power - doesn't need saturation due to (hopefully) low values
		turnPower = turnKP * turnError + turnKI * turnTotal;


		// Now we actually set the motor power
		motorPower(LeftMotor, (distancePower - turnPower));
		motorPower(RightMotor, (distancePower + turnPower));

		// If the robot is within the tolerance, we increment time
		// This is to prevent it from stopping suddenly and retaining momentum.
		if (distanceError < tolerance && distanceError > -tolerance) {
			timeInArea = timeInArea + 1;
		}
		// The loop must keep running - we add a 50ms delay before the next iteration
		delay(50);

		//datalogDataGroupStart();
		//datalogAddValue(0,distanceError);
		//datalogAddValue(1,distanceKP * distanceError);
		//datalogAddValue(2,distanceKI * distanceTotal);
		//datalogAddValue(3,sonarValue);
		//datalogAddValue(4,timeInArea);
		//datalogDataGroupEnd();
	}

	// Reset motors
	motorPower(LeftMotor, 0);
	motorPower(RightMotor, 0);
}

void driveStraightPI(int distance, int tolerance) {
	// Uses two PI controllers
	// one to control the distance to the target, one to control the turning
	// distance and tolerance in millimetres

	// Initialise variables first
	int distanceError = 0;
	int distanceTotal = 0;
	int distancePower = 0;
	int turnError = 0;
	int turnTotal = 0;
	int turnPower = 0;
	int encoderLeft = 0;
	int encoderRight = 0;
	int encoderAverage = 0;
	int encoderDifference = 0;
	int saturateLower = 11;
	int saturateUpper = 125;
	int timeInArea = 0;
	int timeRequiredArea = 40;

	// Initialise kp and ki values - experimental
	float distanceKP = 0.5;
	float distanceKI = 0.01;
	float turnKP = 0.5;
	float turnKI = 0.00;

	// Reset sensors, set distanceError to initial value
	setSensor(LeftEnc, 0);
	setSensor(RightEnc, 0);
	distanceError = distance; // we are 'distance' mm away from target position

	// Begin loop: Have you been within tolerance of target for some time?
	while ( (distanceError > tolerance) || (distanceError < -tolerance) || (timeInArea < timeRequiredArea) ) {
		// Loop begins: get encoder count
		encoderLeft = readSensor(LeftEnc);
		encoderRight = readSensor(RightEnc);
		encoderAverage = (encoderLeft + encoderRight) / 2;
		encoderDifference = (encoderLeft - encoderRight);

		// Calculate distanceError in millimetres
		distanceError = distance - count_to_mm(encoderAverage);
		// If distanceError is between -125/kp and 125/kp (the saturation limits) then add to distanceTotal
		// So that it doesn't add up massive numbers and cause major integrator windup
		if (distanceError > (-saturateUpper / distanceKP) && distanceError < (saturateUpper / distanceKP)) {
			distanceTotal = distanceTotal + distanceError;
		}
		// Calculate turnError in millimetres, add to turnTotal
		// Doesn't need the integrator windup preventor, since error should stay almost at zero
		turnError = encoderDifference;
		turnTotal = turnTotal + turnError;
		// Calculate resulting distance power
		distancePower = distanceKP * distanceError + distanceKI * distanceTotal;

		// Saturate distancePower based on distanceError (either forward or backward)
		if (distanceError > 0) {
			distancePower = saturate(distancePower, saturateLower, saturateUpper);
		} else if (distanceError < 0) {
			distancePower = saturate(distancePower, -saturateUpper, -saturateLower);
		}

		// Calculate turn power - doesn't need saturation due to (hopefully) low values
		turnPower = turnKP * turnError + turnKI * turnTotal;

		// Now we actually set the motor power
		motorPower(LeftMotor, (distancePower - turnPower));
		motorPower(RightMotor, (distancePower + turnPower));

		// If the robot is within the tolerance, we increment time
		// This is to prevent it from stopping suddenly and retaining momentum.
		if ( (distanceError < tolerance) && (distanceError > -tolerance) ) {
			timeInArea = timeInArea + 1;
		}

		// The loop must keep running - we add a 50ms delay before the next iteration
		delay(50);

		//datalogDataGroupStart();
		//datalogAddValue(0,distancePower);
		//datalogAddValue(1,distanceError);
		//datalogAddValue(2,distanceKP * distanceError);
		//datalogAddValue(3,distanceKI * distanceTotal);
		//datalogAddValue(4,turnPower);
		//datalogDataGroupEnd();
	}

	// Reset motors
	motorPower(LeftMotor, 0);
	motorPower(RightMotor, 0);
}

//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------

void followLine(){
	float PwrLeft;
	float PwrRight;

	int defaultPower = 20;
	float sensorError;
	int errorTotal;
	int sensorTarget = 700;
	int time = 0;
	int sensorErrorL;
	int sensorErrorR;

	int blackLine = 0;
	int startLineFollowing = 0;

	int lowerSaturate = 5;
	int upperSaturate = 30;

	int encoderLeftV;
	int encoderRightV;
	int average;

	float Kp;
	float Ki;

	int straight = 0;

	//-1 equals left, 1 equals right
	int lastSeen = -1;
	int upperThreshold = 700;
	int lowerThreshold = 300;

	float straightKp = 1;
	float straightPower;
	float straightError;

	float slowStart = -27;
	float speedUp = 0.1;

	//+ve = clockwise
	int turnPower = 10;

	int StartLineFound = 0;
	int endLineReached = 0;

	int sensorL;
	int sensorM;
	int sensorR;

	int s[3] = {0,0,0};
	float sensors = 0;

	setSensor(LeftEnc,0);
	setSensor(RightEnc,0);


	PwrLeft = 30;
	PwrRight = 30;
	Kp = 0.07;
	Ki = 0.01;
	lowerSaturate = 5;
	upperSaturate = 25;
	while(!startLineFollowing){
		encoderLeftV = readSensor(LeftEnc);
		encoderRightV = readSensor(RightEnc);
		straightError = encoderLeftV - encoderRightV;
		straightPower = straightKp*straightError;

		if((sensorM>=BLACKMIN) && (sensorM<=BLACKMAX)){
			blackLine = 1;
		}

		if(blackLine && (sensorM < 300)){
			startLineFollowing = 1;
		}

		motorPower(LeftMotor, (PwrLeft - straightPower));
		motorPower(RightMotor, (PwrRight + straightPower));

		sensorM = readSensor(MidLight);

		//datalogDataGroupStart();
		//datalogAddValue(0,sensorM);
		//datalogAddValue(1,blackLine);
		//datalogAddValue(2,startLineFollowing);
		//datalogDataGroupEnd();
	}


	Kp = 0.04;
	Ki = 0.002;
	lowerSaturate = 5;
	upperSaturate = 25;
	sensorTarget = 500;
	while(time < 20){
		encoderLeftV = readSensor(LeftEnc);
		encoderRightV = readSensor(RightEnc);
		average = (encoderLeftV + encoderRightV)/2;

		sensorM = readSensor(MidLight);
		straightError = encoderLeftV - encoderRightV;
		straightPower = straightKp*straightError;

		sensorError = sensorTarget - sensorM;

		PwrLeft = Kp*sensorError + Ki*errorTotal - straightPower;
		PwrRight = Kp*sensorError + Ki*errorTotal + straightPower;

		if ( (PwrLeft < upperSaturate) && (PwrLeft > -upperSaturate) && (PwrRight < upperSaturate) && (PwrRight > -upperSaturate)) {
			errorTotal = errorTotal + sensorError;
		}


		PwrLeft = saturate(PwrLeft,-upperSaturate,upperSaturate);
		PwrRight = saturate(PwrRight,-upperSaturate,upperSaturate);

		motorPower(LeftMotor, (PwrLeft));
		motorPower(RightMotor, (PwrRight));

		if ( (sensorError < 120) && (sensorError > -120) ) {
			time = time + 1;
		}else{
			time = 0;
		}

		delay(50);

		//datalogDataGroupStart();
		//datalogAddValue(0,sensorM);
		//datalogAddValue(1,sensorTarget);
		//datalogAddValue(2,Kp*sensorError);
		//datalogAddValue(3,Ki*errorTotal);
		//datalogAddValue(4,sensorError);


		//datalogDataGroupEnd();

	}

	lowerSaturate = 5;
	upperSaturate = 40;
	int lineOffset = 200;
	int lineEdge = 0;
	int offLine = 0;
	int offLineOffset = 1;
	int power = 40;
	while(!endLineReached){
		sensorL = readSensor(LeftLight);
		sensorM = readSensor(MidLight);
		sensorR = readSensor(RightLight);

		if(sensorM > 1300){
			endLineReached = 1;
		}


		if((sensorL > BROWNMIN) && (sensorL < BROWNMAX)){
			s[0] = 1;
		}else if(sensorL < BROWNMIN-lineOffset){
			s[0] = -1;
		}

		if((sensorM > BROWNMIN) && (sensorM < BROWNMAX)){
			s[1] = 1;
			offLine = 0;
		}else if(sensorM < BROWNMIN-lineOffset){
			s[1] = -1;
		}

		if(sensorM > BROWNMIN-lineOffset){
			offLine = 0;
		}

		if((sensorR > BROWNMIN) && (sensorR < BROWNMAX)){
			s[2] = 1;
		}else if(sensorR < BROWNMIN-lineOffset){
			s[2] = -1;
		}


		if(s[0] == 1){
			if(s[1] == 1){
				if(s[2] == 1){
				//111 All on line
					PwrLeft = power;
					PwrRight = -power;
				}else{
				//110 Left two on line
					PwrLeft = power;
					PwrRight = -power+5;
				}
			}else{
				if(s[2] == 1){
				//101 Outside two on line
					PwrLeft = -power;
					PwrRight = -power;
				}else{
				//100 Left on line
					PwrLeft = power+2; //Slight Right Veer
					PwrRight = power;
					lineEdge = 1;
				}
			}
		}else{
			if(s[1] == 1){
				if(s[2] == 1){
				//011 Right two on line
					PwrLeft = power;
					PwrRight = -power;
				}else{
				//010 Middle on line
					PwrLeft = power;
					PwrRight = -power;
					lineEdge = 0;
				}
			}else{
				if(s[2] == 1){
				//001 Right on line
					PwrLeft = 0;
					PwrRight = 0;
				}else{
				//000 None on line
					if((sensorM < offLineOffset) && lineEdge && (sensorL < 300)){
						offLine = 1;
					}

					if((lineEdge == 1) && (offLine)){
						PwrLeft = -power+5;
						PwrRight = power;
					}else{
						PwrLeft = power;
						PwrRight = -power+5;
					}
				}
			}
		}

		PwrLeft = saturate(PwrLeft,-upperSaturate,upperSaturate);
		PwrRight = saturate(PwrRight,-upperSaturate,upperSaturate);

		motorPower(LeftMotor, PwrLeft);
		motorPower(RightMotor, PwrRight);

		delay(20);

		//datalogDataGroupStart();
		//datalogAddValue(0,sensorL);
		//datalogAddValue(1,sensorM);
		//datalogAddValue(2,sensorR);
		//datalogAddValue(3,BROWNMIN);
		//datalogAddValue(4,BROWNMAX);
		//datalogAddValue(5,BROWNMIN-lineOffset);
		//datalogAddValue(6,PwrLeft);
		//datalogAddValue(7,PwrRight);
		//datalogDataGroupEnd();
	}

	driveStraightPI(200,5);


	time = 0;
	sensorTarget = 1300;
	errorTotal = 0;

	turnPI(10);

	Kp = 0.07;
	Ki = 0.01;
	lowerSaturate = 5;
	upperSaturate = 25;
	while(time < 20){
		encoderLeftV = readSensor(LeftEnc);
		encoderRightV = readSensor(RightEnc);
		average = (encoderLeftV + encoderRightV)/2;

		sensorM = readSensor(MidLight);
		straightError = encoderLeftV - encoderRightV;
		straightPower = straightKp*straightError;

		sensorError = sensorTarget - sensorM;

		PwrLeft = Kp*sensorError + Ki*errorTotal + straightPower;
		PwrRight = Kp*sensorError + Ki*errorTotal - straightPower;

		if ( (PwrLeft < upperSaturate) && (PwrLeft > -upperSaturate) && (PwrRight < upperSaturate) && (PwrRight > -upperSaturate)) {
			errorTotal = errorTotal + sensorError;
		}


		PwrLeft = saturate(PwrLeft,-upperSaturate,upperSaturate);
		PwrRight = saturate(PwrRight,-upperSaturate,upperSaturate);

		motorPower(LeftMotor, (-PwrLeft));
		motorPower(RightMotor, (-PwrRight));

		if ( (sensorError < 120) && (sensorError > -120) ) {
			time = time + 1;
		}else{
			time = 0;
		}

		delay(50);

		//datalogDataGroupStart();
		//datalogAddValue(0,sensorM);
		//datalogAddValue(1,sensorTarget);
		//datalogAddValue(2,Kp*sensorError);
		//datalogAddValue(3,Ki*errorTotal);
		//datalogAddValue(4,sensorError);
		//datalogAddValue(5,straightPower);
		//datalogDataGroupEnd();

	}


	int errorTotalR = 0;
	time = 0;
	Kp = 0.05;
	Ki = 0.001;
	upperSaturate = 30;
	Kp = 0.07;
	Ki = 0.01;
	lowerSaturate = 5;
	upperSaturate = 25;
	while(time < 20){
		sensorL = readSensor(LeftLight);
		sensorR = readSensor(RightLight);

		sensorErrorR = sensorL - sensorR;

		PwrRight = Kp*sensorErrorR + Ki*errorTotalR;

		if ((PwrRight < upperSaturate) && (PwrRight > -upperSaturate)) {
			errorTotalR = errorTotalR + sensorErrorR;
		}


		PwrLeft = saturate(PwrLeft,-upperSaturate,upperSaturate);
		PwrRight = saturate(PwrRight,-upperSaturate,upperSaturate);

		motorPower(LeftMotor, (0));
		motorPower(RightMotor, (PwrRight));

		if ( (sensorErrorR < 110) && (sensorErrorR > -110)) {
			time = time + 1;
		}else{
			time = 0;
		}

		delay(50);

		//datalogDataGroupStart();
		//datalogAddValue(0,sensorL);
		//datalogAddValue(1,sensorR);
		//datalogAddValue(2,PwrLeft);
		//datalogAddValue(3,PwrRight);
		//datalogAddValue(4,sensorErrorR);
		//datalogAddValue(5,Kp*sensorErrorR);
		//datalogAddValue(6,Ki*errorTotalR);
		//datalogDataGroupEnd();

	}

	motorPower(LeftMotor, 0);
	motorPower(RightMotor, 0);
}

void completeTheMission()
{
	int distanceTravelled;

	armDown(50);
	resetArmAngle();

	rotateArm(40,1);

	driveToObjectPI(376, 1);

	distanceTravelled = readSensor(RightEnc);
	distanceTravelled = count_to_mm(distanceTravelled);

	rotateArm(-7, 1);

	driveStraightPI(10, 1);
	distanceTravelled = distanceTravelled + 10;

	rotateArm(40, 1);

	distanceTravelled = readSensor(RightEnc);
	distanceTravelled = count_to_mm(distanceTravelled);

	driveStraightPI(-distanceTravelled, 5);
	distanceTravelled = 0;

	turnPI(-90);
	driveStraightPI(713, 3);
	turnPI(80);

	followLine();

	driveStraightPI(348, 3);
	rotateArm(-7, 1);

	driveStraightPI(-20, 3);
	rotateArm(40,5);

	turnPI(90);

	driveStraightPI(1385, 5);

	turnPI(90);

	driveStraightPI(328, 10);
}

task main()
{
	//Background Tasks
	startTask(checkArm);     // DO NOT DELETE THIS LINE
	//startTask(checkButtons); // DO NOT DELETE THIS LINE -- ACTUAL ROBOT
	initialise(robotNumber, isIdeal); // DO NOT DELETE THIS LINE -- ROBOT VW
	//Also comment out waitForStart function!
	//------------------------ Insert main code below this line ---------------------------------
	//-------------------------------------------------------------------------------------------

	int distanceTravelled = 0;

	datalogClear();
	clearDebugStream();

	//waitForStart();//NEVER REMOVE except RVW
	//driveStraightPI(297, 0.01);

	//getLineColour(1,30);

	//followLine();

	//checkSonar();

	completeTheMission();

	//turnPI(-90);
	//driveStraightPI(620, 10);
	//turnPI(80);
	//followLine();

	//distanceTravelled = readSensor(RightEnc);
	//distanceTravelled = count_to_mm(distanceTravelled);
	//driveStraightPI(-distanceTravelled, 5);


	/*
	resetArmAngle();
	rotateArm(0,0.1);
	armUp(50);
	*/

	/*
	armUp(30);

	turnPI(90);
	turnPI(90);
	turnPI(-270);
	turnPI(90);
	*/

	//getLineColour(1,30);

	//setSensor(LeftEnc, 0);
	//setSensor(RightEnc, 0);

	//-------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------
	stopAllTasks();	// DO NOT DELETE THIS LINE - end of program - stop everything
}
